دلایلی برای عدم تمایل به استفاده از ORM ها وجود دارد که از جمله‌‌‌‌ی آن‌ها می‌توان به پیچیده بودن آن‌ها و داشتن انتزاعی ناقص از داده‌های ذخیره شده به صورت رابطه‌ای، اشاره کرد.پیچیدگی آن‌ها عمدتا به دلیل تعامل نادقیق و ساده‌ی آن‌ها با لایه‌ی پایین‌تر یعنی پایگاه داده‌ی رابطه‌ای باز می‌گردد. مشکل و مساله‌ی اصلی از این ناشی می‌شود که در ORM، هدف ایجاد همگامی بین دو نمایش کاملا متفاوت از داده است. یکی داده‌های داخل پایگاه داده‌ی رابطه‌ای و دیگری داده‌های موجود در حافظه. داده‌ساختارهای داخل حافظه‌ای، انعطاف بییشتری از مدل رابطه‌ای دارند و این مساله باعث رغبت بیشتر برنامه‌نویسان به استفاده از آن‌ها و در نتیجه ناچار بودن آن‌ها به استفاده از نگاشت بین این داده‌ساختارها با مدل داده‌ی رابطه‌ای است. اما این نگاشت به دلایلی همچون تفاوت در نحوه‌ی نمایش و ذخیره‌سازی دادهه، توانایی ایجاد تغییر در هر دو طرف نگاشت و دسترسی افراد برای اعمال تغییر همزمان در پایگاه داده،‌ دارای پیچیدگی‌هایی است. از آنجایی که اگر بخواهیم ORM را به کلی کنار بگذاریم، باید جایگزینی برای آن ارائه دهیم، دو راه حل وجود دارد: یکی تلاش برای حل مشکل و دیگری، پیشگیری از به وجود آمدن مشکل.\\


منتقدان ORM معتقد هستند ابزارهایی مانند \lr{Hibernate} ، ناکارآمد هستند و باید جایگزینی سبک‌‌تر به جای آن‌ها توسط خود آن‌ها ساخته و استفاده شود. ساختن ابزار‌های ORM توسط خود برنامه‌نویسان به جای استفاده از ابزارهای موجود، کاری دشوار و پیچیده است و وقتی عمل پس از مدتی از شروع فرآیند ساخت، شما به عنوان یک برنامه‌نویس احساس می‌کنید در یک باتلاق گیر کرده‌اید. اگرچه ابزارهای متن‌بازی همچون iBatis در از بین بردن مشکل نقش اساسی داشته‌اند، اما استفاده از آن‌ها هم چندان ساده نیست. مشکل اصلی اینجا است که این ابزارها عمدتا می‌توانند ۸۰٪ مشکلات را حل کنند در حالی که انتظارات بیشتری از آن‌ها وجود دارد. برنامه‌نویسان دوست دارند تا به مدل رابطه‌ای داده فکر نکنند و این‌کار را به ابزارهای ORM واگذار کنند. اما ۲۰ ٪ باقی‌مانده را کسی باید کنترل کند. اما همچنان استفاده از ابزار‌هایی که ۸۰٪ مساله را حل می‌کنند ارزشمند است و برای ۲۰ ٪ باقی‌مانده نیاز است تا به خوبی به مدل داده‌ی رابطه‌ای مسلط باشیم و طراحی مدل داده‌ای خود را به مدل رابطه‌ای نزدیک نماییم. نهایتا اگر نرم‌افزار ما سبک است یا مثلا فقط قرار است در آن اطلاعات از روی پایگاه داده خوانده شود می‌توان به نوشتن یک ابزار خودساخت فکر کرد اما در عمده‌ی موارد استفاده از ابزارهای موجود بهتر از وارد شدن به پیچیدگی ساخت ابزار‌های خود ساخت است. و اما روش دوم حل مشکل پیشگیری از به وجود آمدن مشکل است. برای این‌کار دو روش وجود دارد. یا مدل رابطه‌ای را در حافظه‌ استفاده کنیم و یا اینکه به کلی از این مدل در پایگاه داده استفاده نکنیم. روش اول به زبان ساده به این معنا‌ است که مانند ابزار‌های CRUD دهه‌ی ۹۰، به زبان رابطه‌ای برنامه‌نویسی کنیم. اما روش دوم را میتوان در پایگاه داده‌های NoSQL خلاصه کرد. اگر نرم‌افزاری داریم که به خوبی با این مدل کار می‌کند، پس بهتر است تا از دردسرهای نگاشت رابطه‌ای دوری کنیم. اما این روش فقط زمانی کارا است که تناسب بین نرم‌افزار و این مدل واقعا تناسب خوبی باشد در حالی که همه‌ی موارد اینگونه نیستند.


ابزارهای ORM دارای پیچیدگی‌هایی در استفاده هستند. این ابزارها از این جهت که بنا است رابطه‌ای مناسب میان دید کاربر از داده که به صورت داده‌ساختارهای متداول وجود دارد، و دید رابطه‌ای داده‌ای، ایجاد کنند و چون این دو دید و انتزاع از داده‌ها فاصله‌ی اساسی با هم دارند، در عمل نمی‌توانند به طور کامل و در کارآمدترین سطح ممکن این ارتباط و نگاشت را برقرار سازند. مسائلی مانند عدم برقراری ارتباط مناسب با لایه‌ی داده‌ی رابطه‌ای زیرین در این ابزارها موجب میشود تا چالش‌های توسعه دهندگاه نرم‌افزار بیشتر شود. آن‌ها نمی‌توانند با خیال آسوده و با این تصور که ابزار‌های ORM موجود همه‌‌ی نیاز را به صورت خودکار برطرف خواهند کرد، به کارهای دیگر خود بپردازند. در نهایت به دو راه حل کلی برای حل این مشکل می‌توان اشاره کرد. راه حل اول این است که مشکل را حل کنیم. دو راه برای این‌کار وجود دارد. یکی اینکه خود توسعه‌دهندگاهن به جای استفاده از ابزارهای ORM موجود و متداول، خود اقدام به ساخت این ابزارها بکنند. شاید در نگاه اول این روش کارآمد به نظر برسد، اما تجربه نشان می‌دهد که هرچه توسعه‌‌دهنده پیش برود بیشتر متوجه می‌شود که این روش بسیار مشکل و پیچیده است و مانند وارد شدن به دنیایی بزرگ است که خروج موفقیت آمیز از آن بسی دشوار است.\\


برای حل مشکل روش دیگری نیز وجود دارد و آن این است که از ابزار‌های متداول و به ويژه متن‌باز موجود استفاده کرد. اما به این مساله نیز توجه داشت که این ابزارها پیچیدگی‌هایی دارند و نمی‌توانند همه‌ی خواسته‌های ما را بر‌آورده سازند و در نتیجه باید خود آن قسمت از خواسته‌های برآورده نشده را برآورده سازیم. ‌می‌توان گفت این ابزارها می‌توانند ۸۰٪ از پیچیدگی‌ها را توسط خود حل نمایند اما ۲۰٪ باقی مانده برعهده‌ی توسعه‌دهندگان است. و اینجا‌ است که که لزوم شناخت مناسب توسعه‌دهندگان از مدل داده‌ی رابطه‌ای مطرح می‌شود. امکان مدیریت کردن ۲۰٪ باقی‌مانده تنها با استفاده از در نظر گرفتن ملزومات مدل رابطه‌ای توسط توسعه‌دهندگان و برنامه‌نویسی بر اساس آن فراهم خواهد بود. در نتیجه در عمده‌ی موارد اینطور به نظر می‌رسد که استفاده از ابزاری که ۸۰٪ مشکل را حل می‌کند به همراه در نظر گرفتن ملزومات مدل رابطه‌ای توسط خود توسعه‌دهندگان بهتر از اقدام به تولید ابزارهای خودساخت با پیچیدگی‌ها و جالش‌های فراوان است که بتوانند ۱۰۰٪ مشکل را حل نمایند. مگر اینکه نرم‌افزاری که می‌خواهیم تولید کنیم خود از پیچیدگی‌های کمی در پردازش داده برخوردار باشد. در این صورت می‌توان به ساخت ابزارها توسط خودمان فکر کنیم. اما راه حل کلی دوم این است که به کلی جلوی ایجاد مشکل را بگیریم. یک راه این است که خود به زبان مدل داده‌ی رابطه‌ای برنامه‌نویسی کنیم و به کلی از ابزارهای ORM استفاده نکنیم. برای این‌کار نیاز داریم تا میزان خوبی تسلط بر این مدل و زبان‌هایی همچون SQL داشته باشیم. روش دیگر نیز این است که به کلی از این مدل داده‌ای استفاده نکنیم و به مدل داده‌ای NoSQL فکر کنیم.  اگرچه این ابزارها شاید به اندازه‌ی پایگاه‌های داده‌ی رابطه‌ای بالغ نباشند،‌ اما در صورتی که مطمئن باشیم نرم‌افزاری که به دنبال ساخت آن هستیم می‌تواند با این مدل به خوبی کار کند، بدون شک می‌توانیم به این مدل به عنوان مدلی کم چالش‌تر از مدل داده‌ای فکر کنیم. اما علامت سوال بزرگ در بسیاری از مواقع این است که آیا واقعا در مورد نرم‌افزار ما این مدل از مدل رابطه‌ای کارآمدتر و ساده‌تر خواهد بود و یا به پیچیدگی‌ها می‌افزاید. پاسخ این سوال نیز ممکن نیست مگر با داشتن شناخت کافی از هر دو مدل و پایگاه‌های داده‌ای.
